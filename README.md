# Arshu Polyglot Assembler Framework using AI

Arshu Assembler is a polyglot declarative framework for app creation, inspired by abstractions from Mustache, React, and HTMX. This project is a multi-language implementation of the original [Arshu Assembler](https://github.com/Arshu/AssembleWebApps/), recreated using AI-assisted development in multiple languages ultimately to replace the original.

Todo Demo of the original Assembler Framework is deployed in [MicroVM (fly.io)](https://flyarshudata.arshucs.com/), [Unikernel (Kraft.cloud)](https://uniarshudata.arshucs.com/) and [Baremetal (OVHCloud)](https://ovharshudata.roottns.com/) with the UI Source in [Arshu Data Github](https://github.com/Arshu/ArshuData/)

This repository represents Phase 2 of a larger project to build a polyglot web framework.

- **Phase 1:** [Arshu Proxy](https://github.com/Arshu/Arshu.Proxy/) (Multi-language Proxy)
- **Phase 2:** **Arshu Static Assembler** (This repository - Static Assembly)
- **Phase 3:** Dynamic Server-Side Assembly (Planned)
- **Phase 4:** Integrated Full-Stack Framework (Planned)

## Collaboration

I am interested in collaborating on the following topics:

Software Assembler, Software Supply Chains, Usage-Based Infrastructure, Distributed Computing, AI-Assisted Development, AI-Assisted Migration, Subscription Freelancing, Sustainable Open Source, Sustainable Free, Building Revenue Centers Instead of Cost Centers for Customers, Financialization of Skills

If you are interested in collaborating, please contact me at srid68 [at] gmail.com.

Pair Programming with AI is available for $100 USD per 4-hour session.

Subscription Freelancing: $250 USD/Month for up to $10,000 USD worth of work. Please contact me with details if interested.

## Demo

| Language       | Assembler Demo in fly.io
| :------------- | :-----------------
| **Javascript** | [javascript Assembler Web](https://jsassembler.fly.dev) Client Side Assembly
| **C#**         | [csharp Assembler Web](https://csharpassembler.fly.dev) Server Side Assembly
| **Rust**       | [rust Assembler Web](https://rustassembler.fly.dev) Server Side Assembly
| **Go**         | [go Assembler Web](https://goassembler.fly.dev) Server Side Assembly
| **Node.js**    | [node Assembler Web](https://nodeassembler.fly.dev) Server Side Assembly
| **PHP**        | [PHP Assembler Web](https://phpassembler.fly.dev) Server Side Assembly

- Fly Machines (network?) are slow but the best and easiest to launch/iterate on and cheap (256MB) when not being used much. Later, I will also deploy it to Unikernel/Baremetal/VM to compare performance.

### Core Features

The framework implements a component-oriented architecture for composing markup and data.

For a detailed explanation of the composition rules, see the [docs/rules documentation](docs/rules.md).

### Implemented Features

- **Component Composition:**
  - **Direct Composition:** Directly compose markup.
  - **Slotted Composition:** Compose markup into numbered slots.
  - **AppView context composition:** Compose markup based on a view context.
- **Data Composition:**
  - **JSON Key Composition:** Merge markup with JSON objects.
  - **JSON Array Composition:** Render markup iteratively with JSON arrays.

## Project Status

| Language       | Assembler (Static) | AssemblerTest | AssemblerWeb
| :------------- | :----------------- | :------------ | :-----------
| **C#**         | ✅ Complete        | ✅ Complete   | ✅ Complete
| **Go**         | ✅ Complete        | ✅ Complete   | ✅ Complete
| **Node.js**    | ✅ Complete        | ✅ Complete   | ✅ Complete
| **PHP**        | ✅ Complete        | ✅ Complete   | ✅ Complete
| **Rust**       | ✅ Complete        | ✅ Complete   | ✅ Complete
| **Javascript** | ✅ Complete        | ✅ Complete   | ✅ Complete

## Project Structure

The repository is organized by language, with each language having a consistent set of subprojects:

```text
/
├── <language>/
│   ├── Assembler/       # Core static site generation logic
│   ├── AssemblerTest/   # Test project for the Assembler
│   └── AssemblerWeb/    # A simple web server exposing the assembler
│   └── AssemblerWebJs/  # A simple web server exposing the Javascript assembler in c#
...
```

## Disclaimer

All the sub projects are at different stages of development and some pending publication.

This README and development notes were created by me but formatted and structured by AI.

The rules document with SVG diagrams was fully generated by Gemini Code Assist by reading the AppSites folder for all five types of rules (not perfect).

This repository is generated by AI based on my prompt requirements, with my focus primarily on architecture, testing, validation, and performance. I have not deeply reviewed the AI-generated implementation logic or data structures, so expect that each language's implementation may not be optimal, but the implementation outputs are accurate and validated by me. I have done minimal debugging of the working code.

Note: I am only familiar with C#, which I used as the prompt for all other languages. I am not familiar with idioms or conventions in other languages.

*Brief (lattter will add to it) AI development notes are in [docs/Development Notes](docs/DevelopmentNotes.md).*

## Prerequisites

Before you begin, ensure you have the following tools installed for the language you wish to work with:

- **C#**: .NET SDK (version 8.0 or later)
- **Go**: Go (version 1.21 or later)
- **Node.js**: Node.js (version 18 or later) and npm
- **PHP**: PHP (version 8.0 or later) and Composer
- **Rust**: Rust and Cargo

## Getting Started

- **Warning: All projects have idle tracking implemented with auto shutdown after 10 seconds of inactivity due to deployment on fly.io. (Usage-Based Infrastructure)**

### CSharp

```bash
# Navigate to the C# directory
cd csharp\AssemblerTest

# Run the tests
dotnet run .

# Run the web application
cd csharp\AssemblerWeb
dotnet run .

# Run the web application for the Javascript Assembler
cd csharp\AssemblerWebJs
dotnet run .

```

### Rust

```bash
# Navigate to the Rust directory
cd rust\AssemblerTest

# Run the tests
cargo run .

# Run the web application
cd AssemblerWeb
cargo run .
```

### Go

```bash
# Navigate to the Go directory
cd go/AssemblerTest

# Run the tests
go run .

# Run the web application
cd ../AssemblerWeb
go run .
```

### Node.js

```bash
# Navigate to the Node.js directory
cd node/AssemblerTest

# Install dependencies and run tests
npm install
node index.js

# Run the web application
cd ../AssemblerWeb
npm install
npm start
```

### PHP

```bash
# Navigate to the PHP directory
cd php/AssemblerTest

# Install dependencies
composer install

# Run the tests (assuming a local PHP server)
php index.php

# Run the web application
cd ../AssemblerWeb
composer install
php -S localhost:8001 index.php
```

#### Planned Features

- **Data Flow:** Hierarchical and cross-cutting data merging strategies.
- **Partial Rendering:** Optimized UI Leaf updates (similar to a virtual DOM).
- **Markup Binding:** HTMX-like event binding for full-stack interactivity.
- **API Connection:** Connect frontend with backend using Ajax, WebSocket, WebRTC, WebTransport, etc., using a uniform API.
- **And many more:** Expression parsing, dynamic content generation, performance tracking, and metadata generation

## Intermediate Goals

The primary goal is to recreate the existing [Arshu Assembler](https://github.com/Arshu/AssembleWebApps/) so that I can improve the abstraction for assembly since i have lots of ideals but lack the time to implement it.

The secondary goal is to recreate the demo applications [Arshu Data](https://github.com/Arshu/ArshuData/), [Arshu Hub](https://github.com/Arshu/ArshuHub/), and the Loyalty Management Application, [Loyalty App](https://shopifyloyalty.arshucs.com/) and other apps which I am developing to be fully recreated in AI so that I can implement features faster using AI.

### Ultimate Goal

Find abstractions which improve reusability in developing applications and can lead to implementing an independent supply chain in software development due to improved abstractions that clearly separate building from assembly.
